/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */
import { Node } from './index';
import { ParamType, Type } from './types';
/** An AST node that can appear directly in a document or namespace. */
export declare type Declaration = GlobalNamespace | Namespace | Class | Interface | Function | ConstValue | Import | Export | TypeAssignment;
export declare class GlobalNamespace {
    readonly kind = "globalNamespace";
    members: Declaration[];
    constructor(members?: Declaration[]);
    traverse(): Iterable<Node>;
    serialize(depth?: number): string;
}
export declare class Namespace {
    readonly kind = "namespace";
    name: string;
    description: string;
    style: 'namespace' | 'module';
    members: Declaration[];
    constructor(data: {
        name: string;
        description?: string;
        members?: Declaration[];
        style?: 'namespace' | 'module';
    });
    traverse(): Iterable<Node>;
    serialize(depth?: number): string;
}
export declare class Class {
    readonly kind = "class";
    name: string;
    description: string;
    extends: string;
    mixins: string[];
    properties: Property[];
    methods: Method[];
    constructorMethod?: Method;
    constructor(data: {
        name: string;
        description?: string;
        extends?: string;
        mixins?: string[];
        properties?: Property[];
        methods?: Method[];
        constructorMethod?: Method;
    });
    traverse(): Iterable<Node>;
    serialize(depth?: number): string;
}
export declare class Interface {
    readonly kind = "interface";
    name: string;
    description: string;
    extends: string[];
    properties: Property[];
    methods: Method[];
    constructor(data: {
        name: string;
        description?: string;
        extends?: string[];
        properties?: Property[];
        methods?: Method[];
    });
    traverse(): Iterable<Node>;
    serialize(depth?: number): string;
}
export declare abstract class FunctionLike {
    kind?: 'method' | 'function';
    name: string;
    description: string;
    params: ParamType[];
    templateTypes: string[];
    returns?: Type;
    returnsDescription: string;
    isStatic: boolean;
    ignoreTypeCheck: boolean;
    constructor(data: {
        name: string;
        description?: string;
        params?: ParamType[];
        templateTypes?: string[];
        returns?: Type;
        returnsDescription?: string;
        isStatic?: boolean;
        ignoreTypeCheck?: boolean;
    });
    serialize(depth?: number): string;
}
export declare class Function extends FunctionLike {
    readonly kind = "function";
    traverse(): Iterable<Node>;
}
export declare class Method extends FunctionLike {
    readonly kind = "method";
    traverse(): Iterable<Node>;
}
export declare class Property {
    readonly kind = "property";
    name: string;
    description: string;
    type: Type;
    readOnly: boolean;
    constructor(data: {
        name: string;
        description?: string;
        type?: Type;
        readOnly?: boolean;
    });
    traverse(): Iterable<Node>;
    serialize(depth?: number): string;
}
export declare class ConstValue {
    readonly kind = "constValue";
    name: string;
    type: Type;
    constructor(data: {
        name: string;
        type: Type;
    });
    traverse(): Iterable<Node>;
    serialize(depth?: number): string;
}
/**
 * The "*" token in an import or export.
 */
export declare const AllIdentifiers: unique symbol;
export declare type AllIdentifiers = typeof AllIdentifiers;
/**
 * An identifier that is imported, possibly with a different name.
 */
export interface ImportSpecifier {
    identifier: string | AllIdentifiers;
    alias?: string;
}
/**
 * A JavaScript module import.
 */
export declare class Import {
    readonly kind = "import";
    identifiers: ImportSpecifier[];
    fromModuleSpecifier: string;
    trailingComment?: string;
    constructor(data: {
        identifiers: ImportSpecifier[];
        fromModuleSpecifier: string;
    });
    traverse(): Iterable<Node>;
    serialize(depth?: number): string;
}
/**
 * An identifier that is imported, possibly with a different name.
 */
export interface ExportSpecifier {
    identifier: string;
    alias?: string;
}
/**
 * A JavaScript module export.
 */
export declare class Export {
    readonly kind = "export";
    identifiers: ExportSpecifier[] | AllIdentifiers;
    fromModuleSpecifier: string;
    trailingComment?: string;
    constructor(data: {
        identifiers: ExportSpecifier[] | AllIdentifiers;
        fromModuleSpecifier?: string;
    });
    traverse(): Iterable<Node>;
    serialize(depth?: number): string;
}
export declare class TypeAssignment {
    readonly kind = "typeAssignment";
    name: string;
    value: Type;
    constructor(data: {
        name: string;
        value: Type;
    });
    traverse(): Iterable<Node>;
    serialize(depth?: number): string;
}
