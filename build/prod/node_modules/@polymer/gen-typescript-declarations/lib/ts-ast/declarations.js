"use strict";
/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt The complete set of authors may be found
 * at http://polymer.github.io/AUTHORS.txt The complete set of contributors may
 * be found at http://polymer.github.io/CONTRIBUTORS.txt Code distributed by
 * Google as part of the polymer project is also subject to an additional IP
 * rights grant found at http://polymer.github.io/PATENTS.txt
 */

Object.defineProperty(exports, "__esModule", {
  value: true
});

const formatting_1 = require("./formatting");

const types_1 = require("./types");

class GlobalNamespace {
  constructor(members) {
    this.kind = 'globalNamespace';
    this.members = members || [];
  }

  *traverse() {
    for (const m of this.members) {
      yield* m.traverse();
    }

    yield this;
  }

  serialize(depth = 0) {
    const i = formatting_1.indent(depth);
    let out = `${i}`;

    if (depth === 0) {
      out += 'declare ';
    }

    out += `global {\n`;

    for (const member of this.members) {
      out += '\n' + member.serialize(depth + 1);
    }

    out += `${i}}\n`;
    return out;
  }

}

exports.GlobalNamespace = GlobalNamespace;

class Namespace {
  constructor(data) {
    this.kind = 'namespace';
    this.name = data.name;
    this.description = data.description || '';
    this.members = data.members || [];
    this.style = data.style || 'namespace';
  }

  *traverse() {
    for (const m of this.members) {
      yield* m.traverse();
    }

    yield this;
  }

  serialize(depth = 0) {
    let out = '';

    if (this.description) {
      out += formatting_1.formatComment(this.description, depth);
    }

    const i = formatting_1.indent(depth);
    out += i;

    if (depth === 0) {
      out += 'declare ';
    }

    let name = this.name;

    if (this.style === 'module') {
      // module names can have syntax that's invalid for namespaces,
      // like 'goog:foo' or './bar.js'
      name = `'${name}'`;
    }

    out += `${this.style} ${name} {\n`;

    for (const member of this.members) {
      out += '\n' + member.serialize(depth + 1);
    }

    out += `${i}}\n`;
    return out;
  }

}

exports.Namespace = Namespace;

class Class {
  constructor(data) {
    this.kind = 'class';
    this.name = data.name;
    this.description = data.description || '';
    this.extends = data.extends || '';
    this.mixins = data.mixins || [];
    this.properties = data.properties || [];
    this.methods = data.methods || [];
    this.constructorMethod = data.constructorMethod;
  }

  *traverse() {
    for (const p of this.properties) {
      yield* p.traverse();
    }

    if (this.constructorMethod) {
      yield* this.constructorMethod.traverse();
    }

    for (const m of this.methods) {
      yield* m.traverse();
    }

    yield this;
  }

  serialize(depth = 0) {
    let out = '';
    const i = formatting_1.indent(depth);

    if (this.description) {
      out += formatting_1.formatComment(this.description, depth);
    }

    out += i;

    if (depth === 0) {
      out += 'declare ';
    }

    out += `class ${this.name}`;

    if (this.mixins.length) {
      const i2 = formatting_1.indent(depth + 1);
      out += ' extends';

      for (const mixin of this.mixins) {
        out += `\n${i2}${mixin}(`;
      }

      out += `\n${i2}${this.extends || 'Object'}`;
      out += ')'.repeat(this.mixins.length);
    } else if (this.extends) {
      out += ' extends ' + this.extends;
    }

    out += ' {\n';

    for (const property of this.properties) {
      out += property.serialize(depth + 1);
    }

    if (this.constructorMethod) {
      out += this.constructorMethod.serialize(depth + 1);
    }

    for (const method of this.methods) {
      out += method.serialize(depth + 1);
    }

    if (!out.endsWith('\n')) {
      out += '\n';
    }

    out += `${i}}\n`;
    return out;
  }

}

exports.Class = Class;

class Interface {
  constructor(data) {
    this.kind = 'interface';
    this.name = data.name;
    this.description = data.description || '';
    this.extends = data.extends || [];
    this.properties = data.properties || [];
    this.methods = data.methods || [];
  }

  *traverse() {
    for (const p of this.properties) {
      yield* p.traverse();
    }

    for (const m of this.methods) {
      yield* m.traverse();
    }

    yield this;
  }

  serialize(depth = 0) {
    let out = '';
    const i = formatting_1.indent(depth);

    if (this.description) {
      out += formatting_1.formatComment(this.description, depth);
    }

    out += i;
    out += `interface ${this.name}`;

    if (this.extends.length) {
      out += ' extends ' + this.extends.join(', ');
    }

    out += ' {\n';

    for (const property of this.properties) {
      out += property.serialize(depth + 1);
    }

    for (const method of this.methods) {
      out += method.serialize(depth + 1);
    }

    if (!out.endsWith('\n')) {
      out += '\n';
    }

    out += `${i}}\n`;
    return out;
  }

}

exports.Interface = Interface;

class FunctionLike {
  constructor(data) {
    this.name = data.name;
    this.description = data.description || '';
    this.params = data.params || [];
    this.returns = data.returns || types_1.anyType;
    this.templateTypes = data.templateTypes || [];
    this.returnsDescription = data.returnsDescription || '';
    this.isStatic = data.isStatic || false;
    this.ignoreTypeCheck = data.ignoreTypeCheck || false;
  }

  serialize(depth = 0) {
    let out = '';
    const i = formatting_1.indent(depth);
    const annotations = [];

    for (const p of this.params) {
      if (p.description) {
        annotations.push(`@param ${p.name} ${p.description}`);
      }
    }

    if (this.returnsDescription) {
      annotations.push(`@returns ${this.returnsDescription}`);
    }

    let combinedDescription = this.description;

    if (annotations.length > 0) {
      if (combinedDescription) {
        combinedDescription += '\n\n';
      }

      combinedDescription += annotations.join('\n');
    }

    if (combinedDescription) {
      out += '\n' + formatting_1.formatComment(combinedDescription, depth);
    }

    if (this.ignoreTypeCheck) {
      out += formatting_1.indent(depth) + '// @ts-ignore\n';
    }

    out += i;

    if (depth === 0) {
      out += 'declare ';
    }

    if (this.kind === 'method' && this.isStatic) {
      out += 'static ';
    }

    if (this.kind === 'function') {
      out += 'function ';
    }

    out += this.name;

    if (this.templateTypes.length > 0) {
      out += `<${this.templateTypes.join(', ')}>`;
    }

    out += '(';
    out += this.params.map(p => p.serialize()).join(', ');
    out += `)`;

    if (this.returns) {
      out += `: ${this.returns.serialize()}`;
    }

    out += `;\n`;
    return out;
  }

}

exports.FunctionLike = FunctionLike;

class Function extends FunctionLike {
  constructor() {
    super(...arguments);
    this.kind = 'function';
  }

  *traverse() {
    for (const p of this.params) {
      yield* p.traverse();
    }

    if (this.returns) {
      yield* this.returns.traverse();
    }

    yield this;
  }

}

exports.Function = Function;

class Method extends FunctionLike {
  constructor() {
    super(...arguments);
    this.kind = 'method';
  }

  *traverse() {
    for (const p of this.params) {
      yield* p.traverse();
    }

    if (this.returns) {
      yield* this.returns.traverse();
    }

    yield this;
  }

}

exports.Method = Method;

class Property {
  constructor(data) {
    this.kind = 'property';
    this.name = data.name;
    this.description = data.description || '';
    this.type = data.type || types_1.anyType;
    this.readOnly = data.readOnly || false;
  }

  *traverse() {
    yield* this.type.traverse();
    yield this;
  }

  serialize(depth = 0) {
    let out = '';
    const i = formatting_1.indent(depth);

    if (this.description) {
      out += '\n' + formatting_1.formatComment(this.description, depth);
    }

    out += i;

    if (this.readOnly) {
      out += 'readonly ';
    }

    out += `${formatting_1.quotePropertyName(this.name)}: ${this.type.serialize()};\n`;
    return out;
  }

}

exports.Property = Property;

class ConstValue {
  constructor(data) {
    this.kind = 'constValue';
    this.name = data.name;
    this.type = data.type;
  }

  *traverse() {
    yield* this.type.traverse();
    yield this;
  }

  serialize(depth = 0) {
    return formatting_1.indent(depth) + (depth === 0 ? 'declare ' : '') + `const ${this.name}: ${this.type.serialize()};\n`;
  }

}

exports.ConstValue = ConstValue;
/**
 * The "*" token in an import or export.
 */

exports.AllIdentifiers = Symbol('*');
/**
 * A JavaScript module import.
 */

class Import {
  constructor(data) {
    this.kind = 'import';
    this.identifiers = data.identifiers;
    this.fromModuleSpecifier = data.fromModuleSpecifier;
  }

  *traverse() {
    yield this;
  }

  serialize(depth = 0) {
    const i = formatting_1.indent(depth);

    if (this.identifiers.some(i => i.identifier === exports.AllIdentifiers)) {
      // Namespace imports have a different form. You can also have a default
      // import, but no named imports.
      const parts = [];

      for (const identifier of this.identifiers) {
        if (identifier.identifier === 'default') {
          parts.push(identifier.alias);
        } else if (identifier.identifier === exports.AllIdentifiers) {
          parts.push(`* as ${identifier.alias}`);
        }
      }

      return `${i}import ${parts.join(', ')} ` + `from '${this.fromModuleSpecifier}';` + `${this.trailingComment || ''}\n`;
    } else {
      const parts = [];

      for (const {
        identifier,
        alias
      } of this.identifiers) {
        if (identifier === exports.AllIdentifiers) {
          // Can't happen, see above.
          continue;
        }

        parts.push(identifier + (alias !== undefined && alias !== identifier ? ` as ${alias}` : ''));
      }

      return `${i}import {${parts.join(', ')}} ` + `from '${this.fromModuleSpecifier}';${this.trailingComment || ''}\n`;
    }
  }

}

exports.Import = Import;
/**
 * A JavaScript module export.
 */

class Export {
  constructor(data) {
    this.kind = 'export';
    this.identifiers = data.identifiers;
    this.fromModuleSpecifier = data.fromModuleSpecifier || '';
  }

  *traverse() {
    yield this;
  }

  serialize(depth = 0) {
    const i = formatting_1.indent(depth);
    let out = `${i}export `;

    if (this.identifiers === exports.AllIdentifiers) {
      out += '*';
    } else {
      const specifiers = this.identifiers.map(({
        identifier,
        alias
      }) => {
        return identifier + (alias !== undefined && alias !== identifier ? ` as ${alias}` : '');
      });
      out += `{${specifiers.join(', ')}}`;
    }

    if (this.fromModuleSpecifier !== '') {
      out += ` from '${this.fromModuleSpecifier}'`;
    }

    out += `;${this.trailingComment || ''}\n`;
    return out;
  }

}

exports.Export = Export;

class TypeAssignment {
  constructor(data) {
    this.kind = 'typeAssignment';
    this.name = data.name;
    this.value = data.value;
  }

  *traverse() {
    yield* this.value.traverse();
    yield this;
  }

  serialize(depth = 0) {
    const i = formatting_1.indent(depth);
    return `${i}type ${this.name} = ${this.value.serialize()};\n`;
  }

}

exports.TypeAssignment = TypeAssignment; //# sourceMappingURL=declarations.js.map