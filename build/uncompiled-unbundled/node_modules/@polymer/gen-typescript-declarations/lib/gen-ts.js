"use strict";var __awaiter=this&&this.__awaiter||function(thisArg,_arguments,P,generator){return new(P||(P=Promise))(function(resolve,reject){function fulfilled(value){try{step(generator.next(value))}catch(e){reject(e)}}function rejected(value){try{step(generator["throw"](value))}catch(e){reject(e)}}function step(result){result.done?resolve(result.value):new P(function(resolve){resolve(result.value)}).then(fulfilled,rejected)}step((generator=generator.apply(thisArg,_arguments||[])).next())})};Object.defineProperty(exports,"__esModule",{value:!0});const babel=require("@babel/types"),fsExtra=require("fs-extra"),minimatch=require("minimatch"),path=require("path"),analyzer=require("polymer-analyzer"),vscode_uri_1=require("vscode-uri"),closure_types_1=require("./closure-types"),es_modules_1=require("./es-modules"),ts=require("./ts-ast"),defaultExclude=["index.html","test/**","demo/**"];function generateDeclarations(rootDir,config){return __awaiter(this,void 0,void 0,function*(){const isBowerProject=!0===(yield fsExtra.pathExists(path.join(rootDir,"bower_components"))),a=new analyzer.Analyzer({urlLoader:new analyzer.FsUrlLoader(rootDir),urlResolver:new analyzer.PackageUrlResolver({packageDir:rootDir,componentDir:isBowerProject?"bower_components/":"node_modules/"}),moduleResolution:isBowerProject?void 0:"node"}),analysis=yield a.analyzePackage(),outFiles=new Map;for(const tsDoc of yield analyzerToAst(analysis,config,rootDir)){outFiles.set(tsDoc.path,tsDoc.serialize())}return outFiles})}exports.generateDeclarations=generateDeclarations;function analyzerToAst(analysis,config,rootDir){return __awaiter(this,void 0,void 0,function*(){const excludeFiles=(config.excludeFiles||config.exclude||defaultExclude).map(p=>new minimatch.Minimatch(p)),addReferences=config.addReferences||{},removeReferencesResolved=new Set((config.removeReferences||[]).map(r=>path.resolve(rootDir,r))),renameTypes=new Map(Object.entries(config.renameTypes||{})),autoImportMap=new Map;if(config.autoImport!==void 0){for(const importPath in config.autoImport){for(const identifier of config.autoImport[importPath]){autoImportMap.set(identifier,importPath)}}}const analyzerDocs=[...analysis.getFeatures({kind:"html-document"}),...analysis.getFeatures({kind:"js-document"})],declarationDocs=new Map;for(const jsDoc of analyzerDocs){if(jsDoc.isInline){continue}const sourcePath=analyzerUrlToRelativePath(jsDoc.url,rootDir);if(sourcePath===void 0){console.warn(`Skipping source document without local file URL: ${jsDoc.url}`);continue}if(excludeFiles.some(r=>r.match(sourcePath))){continue}const filename=makeDeclarationsFilename(sourcePath);let docs=declarationDocs.get(filename);if(!docs){docs=[];declarationDocs.set(filename,docs)}docs.push(jsDoc)}const tsDocs=[],warnings=[...analysis.getWarnings()];for(const[declarationsFilename,analyzerDocs]of declarationDocs){const tsDoc=new ts.Document({path:declarationsFilename,header:makeHeader(analyzerDocs.map(d=>analyzerUrlToRelativePath(d.url,rootDir)).filter(url=>url!==void 0)),tsLintDisables:[{ruleName:"variable-name",why:`Describing an API that's defined elsewhere.`}]});for(const analyzerDoc of analyzerDocs){if(es_modules_1.isEsModuleDocument(analyzerDoc)){tsDoc.isEsModule=!0}}for(const analyzerDoc of analyzerDocs){const generator=new TypeGenerator(tsDoc,analysis,analyzerDoc,rootDir,config.excludeIdentifiers||[]);generator.handleDocument();warnings.push(...generator.warnings)}for(const ref of tsDoc.referencePaths){const resolvedRef=path.resolve(rootDir,path.dirname(tsDoc.path),ref);if(removeReferencesResolved.has(resolvedRef)){tsDoc.referencePaths.delete(ref)}}for(const ref of addReferences[tsDoc.path]||[]){tsDoc.referencePaths.add(path.relative(path.dirname(tsDoc.path),ref))}for(const node of tsDoc.traverse()){if("name"===node.kind){const renamed=renameTypes.get(node.name);if(renamed!==void 0){node.name=renamed}}}addAutoImports(tsDoc,autoImportMap);tsDoc.simplify();tsDocs.push(tsDoc)}const filteredWarnings=warnings.filter(warning=>{if(config.hideWarnings&&warning.severity!==analyzer.Severity.ERROR){return!1}const sourcePath=analyzerUrlToRelativePath(warning.sourceRange.file,rootDir);return sourcePath!==void 0&&!excludeFiles.some(pattern=>pattern.match(sourcePath))}),warningPrinter=new analyzer.WarningPrinter(process.stderr,{maxCodeLines:1});yield warningPrinter.printWarnings(filteredWarnings);if(filteredWarnings.some(warning=>warning.severity===analyzer.Severity.ERROR)){throw new Error("Encountered error generating types.")}if(config.googModules){return tsDocs.map(d=>transformToGoogStyle(d,rootDir))}return tsDocs})}function addAutoImports(tsDoc,autoImport){const alreadyImported=getImportedIdentifiers(tsDoc);for(const node of tsDoc.traverse()){if("name"===node.kind){let importSpecifier=autoImport.get(node.name);if(importSpecifier===void 0){continue}if(alreadyImported.has(node.name)){continue}if(importSpecifier.startsWith(".")){if(makeDeclarationsFilename(importSpecifier)===tsDoc.path){continue}importSpecifier=path.relative(path.dirname(tsDoc.path),importSpecifier);if(!importSpecifier.startsWith(".")){importSpecifier="./"+importSpecifier}}tsDoc.members.push(new ts.Import({identifiers:[{identifier:node.name}],fromModuleSpecifier:importSpecifier}));alreadyImported.add(node.name)}}}function getPackageName(rootDir){let packageInfo;try{packageInfo=JSON.parse(fsExtra.readFileSync(path.join(rootDir,"package.json"),"utf-8"))}catch(_a){return}return packageInfo.name}function googModuleForNameBasedImportSpecifier(spec){const name=spec.replace(/(\.d\.ts|\.js)$/,"").replace(/[-\.](\w)/g,(_,s)=>s.toUpperCase()).replace(/^@/g,"").replace(/\//g,".");return`goog:${name}`}function transformToGoogStyle(tsDoc,rootDir){const packageName=getPackageName(rootDir);if(!tsDoc.isEsModule||!packageName){return tsDoc}for(const child of tsDoc.traverse()){if("import"===child.kind||"export"===child.kind){if(!child.fromModuleSpecifier){continue}let spec=child.fromModuleSpecifier;if(spec.startsWith(".")){spec=path.join(packageName,path.relative(rootDir,path.join(rootDir,path.dirname(tsDoc.path),spec)).replace(/^\.\//,""))}const elementName=spec.split("/")[1];let trailingComment;if(elementName&&!/\./.test(elementName)){trailingComment=` // from //third_party/javascript/polymer/v2/${elementName}`}const googSpecifier=googModuleForNameBasedImportSpecifier(spec);if(googSpecifier!==void 0){child.fromModuleSpecifier=googSpecifier;child.trailingComment=trailingComment}}}let googModuleName=googModuleForNameBasedImportSpecifier(path.join(packageName,tsDoc.path));if(googModuleName===void 0){googModuleName=tsDoc.path}return new ts.Document({path:tsDoc.path,header:tsDoc.header,referencePaths:tsDoc.referencePaths,tsLintDisables:tsDoc.tsLintDisables,isEsModule:!1,members:[new ts.Namespace({name:googModuleName,members:tsDoc.members,style:"module"})]})}function getImportedIdentifiers(tsDoc){const identifiers=new Set;for(const member of tsDoc.members){if("import"===member.kind){for(const{identifier,alias}of member.identifiers){if(identifier!==ts.AllIdentifiers){identifiers.add(alias||identifier)}}}}return identifiers}function analyzerUrlToRelativePath(analyzerUrl,rootDir){const parsed=vscode_uri_1.default.parse(analyzerUrl);if("file"!==parsed.scheme||parsed.authority||!parsed.fsPath){return}return path.relative(rootDir,parsed.fsPath)}function makeDeclarationsFilename(sourceUrl){const parsed=path.parse(sourceUrl);return path.join(parsed.dir,parsed.name)+".d.ts"}function makeHeader(sourceUrls){return`DO NOT EDIT

This file was automatically generated by
  https://github.com/Polymer/tools/tree/master/packages/gen-typescript-declarations

To modify these typings, edit the source file(s):
${sourceUrls.map(url=>"  "+url).join("\n")}`}class TypeGenerator{constructor(root,analysis,analyzerDoc,rootDir,excludeIdentifiers){this.root=root;this.analysis=analysis;this.analyzerDoc=analyzerDoc;this.rootDir=rootDir;this.warnings=[];this.forceResolvable=new Set;this.excludeIdentifiers=new Set(excludeIdentifiers)}warn(feature,message){this.warnings.push(new analyzer.Warning({message,sourceRange:feature.sourceRange,severity:analyzer.Severity.WARNING,code:"GEN_TYPESCRIPT_DECLARATIONS_WARNING",parsedDocument:this.analyzerDoc.parsedDocument}))}handleDocument(){for(const feature of this.analyzerDoc.getFeatures()){if([...feature.identifiers].some(id=>this.excludeIdentifiers.has(id))){continue}if(isPrivate(feature)){continue}if(feature.kinds.has("element")){this.handleElement(feature)}else if(feature.kinds.has("behavior")){this.handleBehavior(feature)}else if(feature.kinds.has("element-mixin")){this.handleMixin(feature)}else if(feature.kinds.has("class")){this.handleClass(feature)}else if(feature.kinds.has("function")){this.handleFunction(feature)}else if(feature.kinds.has("namespace")){this.handleNamespace(feature)}else if(feature.kinds.has("html-import")){if(feature.sourceRange&&feature.sourceRange.file===this.analyzerDoc.url){this.handleHtmlImport(feature)}}else if(feature.kinds.has("js-import")){this.handleJsImport(feature)}else if(feature.kinds.has("export")){this.handleJsExport(feature)}}}handleElement(feature){let constructable,fullName,shortName,parent;if(feature.className){constructable=!0;let namespacePath;[namespacePath,shortName]=splitReference(feature.className);fullName=feature.className;parent=findOrCreateNamespace(this.root,namespacePath)}else if(feature.tagName){constructable=!1;shortName=kebabToCamel(feature.tagName)+"Element";fullName=shortName;parent=this.root}else{this.warn(feature,`Could not find element name.`);return}const legacyPolymerInterfaces=[];if(isPolymerElement(feature)){legacyPolymerInterfaces.push(...feature.behaviorAssignments.map(behavior=>behavior.identifier));if(feature.isLegacyFactoryCall){if(this.root.isEsModule){legacyPolymerInterfaces.push("LegacyElementMixin");if(!getImportedIdentifiers(this.root).has("LegacyElementMixin")){this.root.members.push(new ts.Import({identifiers:[{identifier:"LegacyElementMixin"}],fromModuleSpecifier:"@polymer/polymer/lib/legacy/legacy-element-mixin.js"}))}}else{legacyPolymerInterfaces.push("Polymer.LegacyElementMixin")}legacyPolymerInterfaces.push("HTMLElement")}}if(constructable){this.handleClass(feature);if(0<legacyPolymerInterfaces.length){parent.members.push(new ts.Interface({name:shortName,extends:legacyPolymerInterfaces}))}}else{parent.members.push(new ts.Interface({name:shortName,description:feature.description||feature.summary,properties:this.handleProperties(feature.properties.values()),methods:this.handleMethods(feature.methods.values()),extends:[...feature.mixins.map(mixin=>mixin.identifier),...legacyPolymerInterfaces]}));if(isPolymerElement(feature)&&feature.isLegacyFactoryCall&&this.root.isEsModule){this.root.members.push(new ts.Export({identifiers:[{identifier:shortName}]}))}}if(feature.tagName){const elementMap=findOrCreateInterface(this.root.isEsModule?findOrCreateGlobalNamespace(this.root):this.root,"HTMLElementTagNameMap");elementMap.properties.push(new ts.Property({name:feature.tagName,type:new ts.NameType(fullName)}))}}handleBehavior(feature){if(!feature.className){this.warn(feature,`Could not find a name for behavior.`);return}const[namespacePath,className]=splitReference(feature.className),ns=findOrCreateNamespace(this.root,namespacePath);ns.members.push(new ts.Interface({name:className,description:feature.description||feature.summary,extends:feature.behaviorAssignments.map(b=>b.identifier),properties:this.handleProperties(feature.properties.values()),methods:this.handleMethods(feature.methods.values())}));ns.members.push(new ts.ConstValue({name:className,type:new ts.NameType("object")}))}handleMixin(feature){const[namespacePath,mixinName]=splitReference(feature.name),parentNamespace=findOrCreateNamespace(this.root,namespacePath),transitiveMixins=[...this.transitiveMixins(feature)],constructorName=mixinName+"Constructor";parentNamespace.members.push(new ts.Function({name:mixinName,description:feature.description,templateTypes:["T extends new (...args: any[]) => {}"],params:[new ts.ParamType({name:"base",type:new ts.NameType("T")})],returns:new ts.IntersectionType([new ts.NameType("T"),new ts.NameType(constructorName),...transitiveMixins.map(mixin=>new ts.NameType(mixin.name+"Constructor"))])}));if(this.root.isEsModule){for(const mixin of transitiveMixins){if(mixin.sourceRange===void 0){continue}const rootRelative=analyzerUrlToRelativePath(mixin.sourceRange.file,this.rootDir);if(rootRelative===void 0){continue}const fileRelative=path.relative(path.dirname(this.root.path),rootRelative),fromModuleSpecifier=fileRelative.startsWith(".")?fileRelative:"./"+fileRelative,identifiers=[{identifier:mixin.name+"Constructor"}];if(!getImportedIdentifiers(this.root).has(mixin.name)){identifiers.push({identifier:mixin.name})}this.root.members.push(new ts.Import({identifiers,fromModuleSpecifier}))}}parentNamespace.members.push(new ts.Interface({name:constructorName,methods:[new ts.Method({name:"new",params:[new ts.ParamType({name:"args",type:new ts.ArrayType(ts.anyType),rest:!0})],returns:new ts.NameType(mixinName)}),...this.handleMethods(feature.staticMethods.values())]}));if(this.root.isEsModule){this.root.members.push(new ts.Export({identifiers:[{identifier:constructorName}]}))}parentNamespace.members.push(new ts.Interface({name:mixinName,properties:this.handleProperties(feature.properties.values()),methods:this.handleMethods(feature.methods.values()),extends:transitiveMixins.map(mixin=>mixin.name)}))}transitiveMixins(parentMixin,result){if(result===void 0){result=new Set}for(const childRef of parentMixin.mixins){const childMixinSet=this.analysis.getFeatures({id:childRef.identifier,kind:"element-mixin"});if(1!==childMixinSet.size){this.warn(parentMixin,`Found ${childMixinSet.size} features for mixin `+`${childRef.identifier}, expected 1.`);continue}const childMixin=childMixinSet.values().next().value;result.add(childMixin);this.transitiveMixins(childMixin,result)}return result}handleClass(feature){if(!feature.className){this.warn(feature,`Could not find a name for class.`);return}const[namespacePath,name]=splitReference(feature.className),m=new ts.Class({name});m.description=feature.description;m.properties=this.handleProperties(feature.properties.values());m.methods=[...this.handleMethods(feature.staticMethods.values(),{isStatic:!0}),...this.handleMethods(feature.methods.values())];m.constructorMethod=this.handleConstructorMethod(feature.constructorMethod);if(feature.superClass!==void 0){m.extends=feature.superClass.identifier}m.mixins=feature.mixins.map(mixin=>mixin.identifier);findOrCreateNamespace(this.root,namespacePath).members.push(m)}handleFunction(feature){const[namespacePath,name]=splitReference(feature.name),f=new ts.Function({name,description:feature.description||feature.summary,templateTypes:feature.templateTypes,returns:closure_types_1.closureTypeToTypeScript(feature.return&&feature.return.type,feature.templateTypes),returnsDescription:feature.return&&feature.return.desc});for(const param of feature.params||[]){f.params.push(closure_types_1.closureParamToTypeScript(param.name,param.type,feature.templateTypes))}findOrCreateNamespace(this.root,namespacePath).members.push(f)}handleProperties(analyzerProperties){const tsProperties=[];for(const property of analyzerProperties){if(property.inheritedFrom||"private"===property.privacy||this.excludeIdentifiers.has(property.name)){continue}const p=new ts.Property({name:property.name,type:closure_types_1.closureTypeToTypeScript(property.type),readOnly:property.readOnly});p.description=property.description||"";tsProperties.push(p)}return tsProperties}handleMethods(analyzerMethods,opts){const tsMethods=[];for(const method of analyzerMethods){if(method.inheritedFrom||"private"===method.privacy||this.excludeIdentifiers.has(method.name)){continue}tsMethods.push(this.handleMethod(method,opts))}return tsMethods}handleMethod(method,opts){const m=new ts.Method({name:method.name,returns:closure_types_1.closureTypeToTypeScript(method.return&&method.return.type),returnsDescription:method.return&&method.return.desc,isStatic:opts&&opts.isStatic,ignoreTypeCheck:this.documentationHasSuppressTypeCheck(method.jsdoc)});m.description=method.description||"";let requiredAhead=!1;for(const param of reverseIter(method.params||[])){const tsParam=closure_types_1.closureParamToTypeScript(param.name,param.type);tsParam.description=param.description||"";if(param.defaultValue!==void 0){if(!requiredAhead){tsParam.optional=!0}else{tsParam.type=new ts.UnionType([tsParam.type,ts.undefinedType])}}else if(!tsParam.optional){requiredAhead=!0}tsParam.rest=tsParam.rest||!!param.rest;if(tsParam.rest&&"array"!==tsParam.type.kind){tsParam.type=new ts.ArrayType(tsParam.type)}m.params.unshift(tsParam)}return m}documentationHasSuppressTypeCheck(annotation){if(!annotation){return!1}const annotationValue=annotation.tags.find(e=>"suppress"===e.title);return annotationValue&&"{checkTypes}"===annotationValue.description||!1}handleConstructorMethod(method){if(!method){return}const m=this.handleMethod(method);m.returns=void 0;return m}handleNamespace(feature){const ns=findOrCreateNamespace(this.root,feature.name.split("."));if("namespace"===ns.kind){ns.description=feature.description||feature.summary||""}}handleJsImport(feature){const node=feature.astNode.node;if(babel.isImportDeclaration(node)){const identifiers=[];for(const specifier of node.specifiers){if(babel.isImportSpecifier(specifier)){if(this.isResolvable(specifier.imported.name,feature)){identifiers.push({identifier:specifier.imported.name,alias:specifier.local.name})}}else if(babel.isImportDefaultSpecifier(specifier)){if(this.isResolvable("default",feature)){identifiers.push({identifier:"default",alias:specifier.local.name})}}else if(babel.isImportNamespaceSpecifier(specifier)){identifiers.push({identifier:ts.AllIdentifiers,alias:specifier.local.name});this.forceResolvable.add(specifier.local.name)}}if(0<identifiers.length){this.root.members.push(new ts.Import({identifiers:identifiers,fromModuleSpecifier:node.source&&node.source.value}))}}else if(!babel.isExportNamedDeclaration(node)&&!babel.isExportAllDeclaration(node)){this.warn(feature,`Import with AST type ${node.type} not supported.`)}}handleJsExport(feature){const node=feature.astNode.node;if(babel.isExportAllDeclaration(node)){this.root.members.push(new ts.Export({identifiers:ts.AllIdentifiers,fromModuleSpecifier:node.source&&node.source.value}))}else if(babel.isExportNamedDeclaration(node)){const identifiers=[];if(node.declaration){for(const identifier of feature.identifiers){if(this.isResolvable(identifier,feature)){identifiers.push({identifier})}}}else{for(const specifier of node.specifiers){if(this.isResolvable(specifier.exported.name,feature)||this.isResolvable(specifier.local.name,feature)){identifiers.push({identifier:specifier.local.name,alias:specifier.exported.name})}}}if(0<identifiers.length){this.root.members.push(new ts.Export({identifiers,fromModuleSpecifier:node.source&&node.source.value}))}}else{this.warn(feature,`Export feature with AST node type ${node.type} not supported.`)}}isResolvable(identifier,fromFeature){if(this.forceResolvable.has(identifier)){return!0}const resolved=es_modules_1.resolveImportExportFeature(fromFeature,identifier,this.analyzerDoc);return resolved!==void 0&&resolved.feature!==void 0&&!isPrivate(resolved.feature)&&!isBehaviorImpl(resolved)}handleHtmlImport(feature){let sourcePath=analyzerUrlToRelativePath(feature.url,this.rootDir);if(sourcePath===void 0){this.warn(feature,`Skipping HTML import without local file URL: ${feature.url}`);return}sourcePath=sourcePath.replace(/^(bower_components|node_modules)\//,"../");sourcePath=sourcePath.replace(/^\.\.\/polymer\//,"../polymer/types/");this.root.referencePaths.add(path.relative(path.dirname(this.root.path),makeDeclarationsFilename(sourcePath)))}}function*reverseIter(arr){for(let i=arr.length-1;0<=i;i--){yield arr[i]}}function findOrCreateGlobalNamespace(doc){for(const member of doc.members){if("globalNamespace"===member.kind){return member}}const globalNamespace=new ts.GlobalNamespace;doc.members.push(globalNamespace);return globalNamespace}function findOrCreateNamespace(root,path){if(!path.length){return root}let first;for(const member of root.members){if("namespace"===member.kind&&member.name===path[0]){first=member;break}}if(!first){first=new ts.Namespace({name:path[0]});root.members.push(first)}return findOrCreateNamespace(first,path.slice(1))}function findOrCreateInterface(root,reference){const[namespacePath,name]=splitReference(reference),namespace_=findOrCreateNamespace(root,namespacePath);for(const member of namespace_.members){if("interface"===member.kind&&member.name===name){return member}}const i=new ts.Interface({name});namespace_.members.push(i);return i}function isPolymerElement(feature){return feature.kinds.has("polymer-element")}function isBehaviorImpl(reference){return reference.feature!==void 0&&reference.feature.kinds.has("behavior")&&reference.feature.name!==reference.identifier}function isPrivate(feature){return"private"===feature.privacy}function kebabToCamel(s){return s.replace(/(^|-)(.)/g,(_match,_p0,p1)=>p1.toUpperCase())}function splitReference(reference){const parts=reference.split("."),namespacePath=parts.slice(0,-1),name=parts[parts.length-1];return[namespacePath,name]}