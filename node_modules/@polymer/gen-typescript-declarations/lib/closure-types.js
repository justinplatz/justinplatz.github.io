"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const ts=require("./ts-ast"),{parseType,parseParamType}=require("doctrine/lib/typed.js");function closureTypeToTypeScript(closureType,templateTypes=[]){if(!closureType){return ts.anyType}let ast;try{ast=parseType(closureType)}catch(_a){return ts.anyType}return convert(ast,templateTypes)}exports.closureTypeToTypeScript=closureTypeToTypeScript;function closureParamToTypeScript(name,closureType,templateTypes=[]){if(!closureType){return new ts.ParamType({name,type:ts.anyType,optional:!1,rest:!1})}let ast;try{ast=parseParamType(closureType)}catch(_a){return new ts.ParamType({name,type:ts.anyType,optional:closureType.endsWith("="),rest:!1})}return convertParam(name,ast,templateTypes)}exports.closureParamToTypeScript=closureParamToTypeScript;function convertParam(name,node,templateTypes){switch(node.type){case"OptionalType":return new ts.ParamType({name,type:convert(node.expression,templateTypes),optional:!0,rest:!1});case"RestType":return new ts.ParamType({name,type:new ts.ArrayType(node.expression!==void 0?convert(node.expression,templateTypes):ts.anyType),optional:!1,rest:!0});default:return new ts.ParamType({name,type:convert(node,templateTypes),optional:!1,rest:!1});}}function convert(node,templateTypes){let nullable;if(isNullable(node)){nullable=!0;node=node.expression}else if(isNonNullable(node)){nullable=!1;node=node.expression}else if(isName(node)&&templateTypes.includes(node.name)){nullable=!1}else{nullable=nullableByDefault(node)}let t;if(isParameterizedArray(node)){t=convertArray(node,templateTypes)}else if(isParameterizedObject(node)){t=convertIndexableObject(node,templateTypes)}else if(isBarePromise(node)){t=new ts.ParameterizedType("Promise",[ts.anyType])}else if(isParameterizedType(node)){t=convertParameterizedType(node,templateTypes)}else if(isUnion(node)){t=convertUnion(node,templateTypes)}else if(isFunction(node)){t=convertFunction(node,templateTypes)}else if(isBareArray(node)){t=new ts.ArrayType(ts.anyType)}else if(isRecordType(node)){t=convertRecord(node,templateTypes)}else if(isAllLiteral(node)){t=ts.anyType}else if(isNullableLiteral(node)){t=ts.anyType}else if(isNullLiteral(node)){t=ts.nullType}else if(isUndefinedLiteral(node)){t=ts.undefinedType}else if(isVoidLiteral(node)){t=new ts.NameType("void")}else if(isName(node)){t=new ts.NameType(renameMap.get(node.name)||node.name)}else{console.error("Unknown syntax.");return ts.anyType}if(nullable){t=new ts.UnionType([t,ts.nullType])}return t}const renameMap=new Map([["Object","object"],["ITemplateArray","TemplateStringsArray"]]),parameterizedRenameMap=new Map([["HTMLCollection","HTMLCollectionOf"],["NodeList","NodeListOf"]]);function nullableByDefault(node){if(isName(node)){switch(node.name){case"string":case"number":case"boolean":case"void":return!1;}return!0}return isParameterizedArray(node)}function convertArray(node,templateTypes){const applications=node.applications;return new ts.ArrayType(1===applications.length?convert(applications[0],templateTypes):ts.anyType)}function convertIndexableObject(node,templateTypes){if(2!==node.applications.length){console.error("Parameterized Object must have two parameters.");return ts.anyType}return new ts.IndexableObjectType(convert(node.applications[0],templateTypes),convert(node.applications[1],templateTypes))}function convertParameterizedType(node,templateTypes){if(!isName(node.expression)){console.error("Could not find name of parameterized type");return ts.anyType}const types=node.applications.map(application=>convert(application,templateTypes)),name=renameMap.get(node.expression.name)||parameterizedRenameMap.get(node.expression.name)||node.expression.name;return new ts.ParameterizedType(name,types)}function convertUnion(node,templateTypes){return new ts.UnionType(node.elements.map(element=>convert(element,templateTypes)))}function convertFunction(node,templateTypes){const params=node.params.map((param,idx)=>convertParam("p"+idx,param,templateTypes));if(node.new){return new ts.ConstructorType(params,isName(node.this)?new ts.NameType(node.this.name):ts.anyType)}else{return new ts.FunctionType(params,node.result?convert(node.result,templateTypes):ts.anyType)}}function convertRecord(node,templateTypes){const fields=[];for(const field of node.fields){if("FieldType"!==field.type){return ts.anyType}const fieldType=field.value?convert(field.value,templateTypes):ts.anyType;let optional=!1;if("union"===fieldType.kind){fieldType.members=fieldType.members.filter(member=>{if("name"===member.kind&&"undefined"===member.name){optional=!0;return!1}return!0});fieldType.simplify()}fields.push(new ts.ParamType({name:field.key,type:fieldType,optional}))}return new ts.RecordType(fields)}function isParameterizedArray(node){return"TypeApplication"===node.type&&"NameExpression"===node.expression.type&&"Array"===node.expression.name}function isParameterizedType(node){return"TypeApplication"===node.type}function isBareArray(node){return"NameExpression"===node.type&&"Array"===node.name}function isBarePromise(node){return"NameExpression"===node.type&&"Promise"===node.name}function isParameterizedObject(node){return"TypeApplication"===node.type&&"NameExpression"===node.expression.type&&"Object"===node.expression.name}function isUnion(node){return"UnionType"===node.type}function isFunction(node){return"FunctionType"===node.type}function isRecordType(node){return"RecordType"===node.type}function isNullable(node){return"NullableType"===node.type}function isNonNullable(node){return"NonNullableType"===node.type}function isAllLiteral(node){return"AllLiteral"===node.type}function isNullLiteral(node){return"NullLiteral"===node.type}function isNullableLiteral(node){return"NullableLiteral"===node.type}function isUndefinedLiteral(node){return"UndefinedLiteral"===node.type}function isVoidLiteral(node){return"VoidLiteral"===node.type}function isName(node){return"NameExpression"===node.type}