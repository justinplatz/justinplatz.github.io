module.exports=function(chai,_){var Assertion=chai.Assertion,toString=Object.prototype.toString,flag=_.flag;["to","be","been","is","and","has","have","with","that","which","at","of","same"].forEach(function(chain){Assertion.addProperty(chain,function(){return this})});Assertion.addProperty("not",function(){flag(this,"negate",!0)});Assertion.addProperty("deep",function(){flag(this,"deep",!0)});Assertion.addProperty("any",function(){flag(this,"any",!0);flag(this,"all",!1)});Assertion.addProperty("all",function(){flag(this,"all",!0);flag(this,"any",!1)});function an(type,msg){if(msg)flag(this,"message",msg);type=type.toLowerCase();var obj=flag(this,"object"),article=~["a","e","i","o","u"].indexOf(type.charAt(0))?"an ":"a ";this.assert(type===_.type(obj),"expected #{this} to be "+article+type,"expected #{this} not to be "+article+type)}Assertion.addChainableMethod("an",an);Assertion.addChainableMethod("a",an);function includeChainingBehavior(){flag(this,"contains",!0)}function include(val,msg){_.expectTypes(this,["array","object","string"]);if(msg)flag(this,"message",msg);var obj=flag(this,"object"),expected=!1;if("array"===_.type(obj)&&"object"===_.type(val)){for(var i in obj){if(_.eql(obj[i],val)){expected=!0;break}}}else if("object"===_.type(val)){if(!flag(this,"negate")){for(var k in val)new Assertion(obj).property(k,val[k]);return}var subset={};for(var k in val)subset[k]=obj[k];expected=_.eql(subset,val)}else{expected=obj!=void 0&&~obj.indexOf(val)}this.assert(expected,"expected #{this} to include "+_.inspect(val),"expected #{this} to not include "+_.inspect(val))}Assertion.addChainableMethod("include",include,includeChainingBehavior);Assertion.addChainableMethod("contain",include,includeChainingBehavior);Assertion.addChainableMethod("contains",include,includeChainingBehavior);Assertion.addChainableMethod("includes",include,includeChainingBehavior);Assertion.addProperty("ok",function(){this.assert(flag(this,"object"),"expected #{this} to be truthy","expected #{this} to be falsy")});Assertion.addProperty("true",function(){this.assert(!0===flag(this,"object"),"expected #{this} to be true","expected #{this} to be false",this.negate?!1:!0)});Assertion.addProperty("false",function(){this.assert(!1===flag(this,"object"),"expected #{this} to be false","expected #{this} to be true",this.negate?!0:!1)});Assertion.addProperty("null",function(){this.assert(null===flag(this,"object"),"expected #{this} to be null","expected #{this} not to be null")});Assertion.addProperty("undefined",function(){this.assert(void 0===flag(this,"object"),"expected #{this} to be undefined","expected #{this} not to be undefined")});Assertion.addProperty("NaN",function(){this.assert(isNaN(flag(this,"object")),"expected #{this} to be NaN","expected #{this} not to be NaN")});Assertion.addProperty("exist",function(){this.assert(null!=flag(this,"object"),"expected #{this} to exist","expected #{this} to not exist")});Assertion.addProperty("empty",function(){var obj=flag(this,"object"),expected=obj;if(Array.isArray(obj)||"string"===typeof object){expected=obj.length}else if("object"===typeof obj){expected=Object.keys(obj).length}this.assert(!expected,"expected #{this} to be empty","expected #{this} not to be empty")});function checkArguments(){var obj=flag(this,"object"),type=Object.prototype.toString.call(obj);this.assert("[object Arguments]"===type,"expected #{this} to be arguments but got "+type,"expected #{this} to not be arguments")}Assertion.addProperty("arguments",checkArguments);Assertion.addProperty("Arguments",checkArguments);function assertEqual(val,msg){if(msg)flag(this,"message",msg);var obj=flag(this,"object");if(flag(this,"deep")){return this.eql(val)}else{this.assert(val===obj,"expected #{this} to equal #{exp}","expected #{this} to not equal #{exp}",val,this._obj,!0)}}Assertion.addMethod("equal",assertEqual);Assertion.addMethod("equals",assertEqual);Assertion.addMethod("eq",assertEqual);function assertEql(obj,msg){if(msg)flag(this,"message",msg);this.assert(_.eql(obj,flag(this,"object")),"expected #{this} to deeply equal #{exp}","expected #{this} to not deeply equal #{exp}",obj,this._obj,!0)}Assertion.addMethod("eql",assertEql);Assertion.addMethod("eqls",assertEql);function assertAbove(n,msg){if(msg)flag(this,"message",msg);var obj=flag(this,"object");if(flag(this,"doLength")){new Assertion(obj,msg).to.have.property("length");var len=obj.length;this.assert(len>n,"expected #{this} to have a length above #{exp} but got #{act}","expected #{this} to not have a length above #{exp}",n,len)}else{this.assert(obj>n,"expected #{this} to be above "+n,"expected #{this} to be at most "+n)}}Assertion.addMethod("above",assertAbove);Assertion.addMethod("gt",assertAbove);Assertion.addMethod("greaterThan",assertAbove);function assertLeast(n,msg){if(msg)flag(this,"message",msg);var obj=flag(this,"object");if(flag(this,"doLength")){new Assertion(obj,msg).to.have.property("length");var len=obj.length;this.assert(len>=n,"expected #{this} to have a length at least #{exp} but got #{act}","expected #{this} to have a length below #{exp}",n,len)}else{this.assert(obj>=n,"expected #{this} to be at least "+n,"expected #{this} to be below "+n)}}Assertion.addMethod("least",assertLeast);Assertion.addMethod("gte",assertLeast);function assertBelow(n,msg){if(msg)flag(this,"message",msg);var obj=flag(this,"object");if(flag(this,"doLength")){new Assertion(obj,msg).to.have.property("length");var len=obj.length;this.assert(len<n,"expected #{this} to have a length below #{exp} but got #{act}","expected #{this} to not have a length below #{exp}",n,len)}else{this.assert(obj<n,"expected #{this} to be below "+n,"expected #{this} to be at least "+n)}}Assertion.addMethod("below",assertBelow);Assertion.addMethod("lt",assertBelow);Assertion.addMethod("lessThan",assertBelow);function assertMost(n,msg){if(msg)flag(this,"message",msg);var obj=flag(this,"object");if(flag(this,"doLength")){new Assertion(obj,msg).to.have.property("length");var len=obj.length;this.assert(len<=n,"expected #{this} to have a length at most #{exp} but got #{act}","expected #{this} to have a length above #{exp}",n,len)}else{this.assert(obj<=n,"expected #{this} to be at most "+n,"expected #{this} to be above "+n)}}Assertion.addMethod("most",assertMost);Assertion.addMethod("lte",assertMost);Assertion.addMethod("within",function(start,finish,msg){if(msg)flag(this,"message",msg);var obj=flag(this,"object"),range=start+".."+finish;if(flag(this,"doLength")){new Assertion(obj,msg).to.have.property("length");var len=obj.length;this.assert(len>=start&&len<=finish,"expected #{this} to have a length within "+range,"expected #{this} to not have a length within "+range)}else{this.assert(obj>=start&&obj<=finish,"expected #{this} to be within "+range,"expected #{this} to not be within "+range)}});function assertInstanceOf(constructor,msg){if(msg)flag(this,"message",msg);var name=_.getName(constructor);this.assert(flag(this,"object")instanceof constructor,"expected #{this} to be an instance of "+name,"expected #{this} to not be an instance of "+name)};Assertion.addMethod("instanceof",assertInstanceOf);Assertion.addMethod("instanceOf",assertInstanceOf);Assertion.addMethod("property",function(name,val,msg){if(msg)flag(this,"message",msg);var isDeep=!!flag(this,"deep"),descriptor=isDeep?"deep property ":"property ",negate=flag(this,"negate"),obj=flag(this,"object"),pathInfo=isDeep?_.getPathInfo(name,obj):null,hasProperty=isDeep?pathInfo.exists:_.hasProperty(name,obj),value=isDeep?pathInfo.value:obj[name];if(negate&&1<arguments.length){if(void 0===value){msg=null!=msg?msg+": ":"";throw new Error(msg+_.inspect(obj)+" has no "+descriptor+_.inspect(name))}}else{this.assert(hasProperty,"expected #{this} to have a "+descriptor+_.inspect(name),"expected #{this} to not have "+descriptor+_.inspect(name))}if(1<arguments.length){this.assert(val===value,"expected #{this} to have a "+descriptor+_.inspect(name)+" of #{exp}, but got #{act}","expected #{this} to not have a "+descriptor+_.inspect(name)+" of #{act}",val,value)}flag(this,"object",value)});function assertOwnProperty(name,msg){if(msg)flag(this,"message",msg);var obj=flag(this,"object");this.assert(obj.hasOwnProperty(name),"expected #{this} to have own property "+_.inspect(name),"expected #{this} to not have own property "+_.inspect(name))}Assertion.addMethod("ownProperty",assertOwnProperty);Assertion.addMethod("haveOwnProperty",assertOwnProperty);function assertOwnPropertyDescriptor(name,descriptor,msg){if("string"===typeof descriptor){msg=descriptor;descriptor=null}if(msg)flag(this,"message",msg);var obj=flag(this,"object"),actualDescriptor=Object.getOwnPropertyDescriptor(Object(obj),name);if(actualDescriptor&&descriptor){this.assert(_.eql(descriptor,actualDescriptor),"expected the own property descriptor for "+_.inspect(name)+" on #{this} to match "+_.inspect(descriptor)+", got "+_.inspect(actualDescriptor),"expected the own property descriptor for "+_.inspect(name)+" on #{this} to not match "+_.inspect(descriptor),descriptor,actualDescriptor,!0)}else{this.assert(actualDescriptor,"expected #{this} to have an own property descriptor for "+_.inspect(name),"expected #{this} to not have an own property descriptor for "+_.inspect(name))}flag(this,"object",actualDescriptor)}Assertion.addMethod("ownPropertyDescriptor",assertOwnPropertyDescriptor);Assertion.addMethod("haveOwnPropertyDescriptor",assertOwnPropertyDescriptor);function assertLengthChain(){flag(this,"doLength",!0)}function assertLength(n,msg){if(msg)flag(this,"message",msg);var obj=flag(this,"object");new Assertion(obj,msg).to.have.property("length");var len=obj.length;this.assert(len==n,"expected #{this} to have a length of #{exp} but got #{act}","expected #{this} to not have a length of #{act}",n,len)}Assertion.addChainableMethod("length",assertLength,assertLengthChain);Assertion.addMethod("lengthOf",assertLength);function assertMatch(re,msg){if(msg)flag(this,"message",msg);var obj=flag(this,"object");this.assert(re.exec(obj),"expected #{this} to match "+re,"expected #{this} not to match "+re)}Assertion.addMethod("match",assertMatch);Assertion.addMethod("matches",assertMatch);Assertion.addMethod("string",function(str,msg){if(msg)flag(this,"message",msg);var obj=flag(this,"object");new Assertion(obj,msg).is.a("string");this.assert(~obj.indexOf(str),"expected #{this} to contain "+_.inspect(str),"expected #{this} to not contain "+_.inspect(str))});function assertKeys(keys){var obj=flag(this,"object"),str,ok=!0,mixedArgsMsg="keys must be given single argument of Array|Object|String, or multiple String arguments";switch(_.type(keys)){case"array":if(1<arguments.length)throw new Error(mixedArgsMsg);break;case"object":if(1<arguments.length)throw new Error(mixedArgsMsg);keys=Object.keys(keys);break;default:keys=Array.prototype.slice.call(arguments);}if(!keys.length)throw new Error("keys required");var actual=Object.keys(obj),expected=keys,len=keys.length,any=flag(this,"any"),all=flag(this,"all");if(!any&&!all){all=!0}if(any){var intersection=expected.filter(function(key){return~actual.indexOf(key)});ok=0<intersection.length}if(all){ok=keys.every(function(key){return~actual.indexOf(key)});if(!flag(this,"negate")&&!flag(this,"contains")){ok=ok&&keys.length==actual.length}}if(1<len){keys=keys.map(function(key){return _.inspect(key)});var last=keys.pop();if(all){str=keys.join(", ")+", and "+last}if(any){str=keys.join(", ")+", or "+last}}else{str=_.inspect(keys[0])}str=(1<len?"keys ":"key ")+str;str=(flag(this,"contains")?"contain ":"have ")+str;this.assert(ok,"expected #{this} to "+str,"expected #{this} to not "+str,expected.slice(0).sort(),actual.sort(),!0)}Assertion.addMethod("keys",assertKeys);Assertion.addMethod("key",assertKeys);function assertThrows(constructor,errMsg,msg){if(msg)flag(this,"message",msg);var obj=flag(this,"object");new Assertion(obj,msg).is.a("function");var thrown=!1,desiredError=null,name=null,thrownError=null;if(0===arguments.length){errMsg=null;constructor=null}else if(constructor&&(constructor instanceof RegExp||"string"===typeof constructor)){errMsg=constructor;constructor=null}else if(constructor&&constructor instanceof Error){desiredError=constructor;constructor=null;errMsg=null}else if("function"===typeof constructor){name=constructor.prototype.name;if(!name||"Error"===name&&constructor!==Error){name=constructor.name||new constructor().name}}else{constructor=null}try{obj()}catch(err){if(desiredError){this.assert(err===desiredError,"expected #{this} to throw #{exp} but #{act} was thrown","expected #{this} to not throw #{exp}",desiredError instanceof Error?desiredError.toString():desiredError,err instanceof Error?err.toString():err);flag(this,"object",err);return this}if(constructor){this.assert(err instanceof constructor,"expected #{this} to throw #{exp} but #{act} was thrown","expected #{this} to not throw #{exp} but #{act} was thrown",name,err instanceof Error?err.toString():err);if(!errMsg){flag(this,"object",err);return this}}var message="error"===_.type(err)&&"message"in err?err.message:""+err;if(null!=message&&errMsg&&errMsg instanceof RegExp){this.assert(errMsg.exec(message),"expected #{this} to throw error matching #{exp} but got #{act}","expected #{this} to throw error not matching #{exp}",errMsg,message);flag(this,"object",err);return this}else if(null!=message&&errMsg&&"string"===typeof errMsg){this.assert(~message.indexOf(errMsg),"expected #{this} to throw error including #{exp} but got #{act}","expected #{this} to throw error not including #{act}",errMsg,message);flag(this,"object",err);return this}else{thrown=!0;thrownError=err}}var actuallyGot="",expectedThrown=null!==name?name:desiredError?"#{exp}":"an error";if(thrown){actuallyGot=" but #{act} was thrown"}this.assert(!0===thrown,"expected #{this} to throw "+expectedThrown+actuallyGot,"expected #{this} to not throw "+expectedThrown+actuallyGot,desiredError instanceof Error?desiredError.toString():desiredError,thrownError instanceof Error?thrownError.toString():thrownError);flag(this,"object",thrownError)};Assertion.addMethod("throw",assertThrows);Assertion.addMethod("throws",assertThrows);Assertion.addMethod("Throw",assertThrows);function respondTo(method,msg){if(msg)flag(this,"message",msg);var obj=flag(this,"object"),itself=flag(this,"itself"),context="function"===_.type(obj)&&!itself?obj.prototype[method]:obj[method];this.assert("function"===typeof context,"expected #{this} to respond to "+_.inspect(method),"expected #{this} to not respond to "+_.inspect(method))}Assertion.addMethod("respondTo",respondTo);Assertion.addMethod("respondsTo",respondTo);Assertion.addProperty("itself",function(){flag(this,"itself",!0)});function satisfy(matcher,msg){if(msg)flag(this,"message",msg);var obj=flag(this,"object"),result=matcher(obj);this.assert(result,"expected #{this} to satisfy "+_.objDisplay(matcher),"expected #{this} to not satisfy"+_.objDisplay(matcher),this.negate?!1:!0,result)}Assertion.addMethod("satisfy",satisfy);Assertion.addMethod("satisfies",satisfy);function closeTo(expected,delta,msg){if(msg)flag(this,"message",msg);var obj=flag(this,"object");new Assertion(obj,msg).is.a("number");if("number"!==_.type(expected)||"number"!==_.type(delta)){throw new Error("the arguments to closeTo or approximately must be numbers")}this.assert(Math.abs(obj-expected)<=delta,"expected #{this} to be close to "+expected+" +/- "+delta,"expected #{this} not to be close to "+expected+" +/- "+delta)}Assertion.addMethod("closeTo",closeTo);Assertion.addMethod("approximately",closeTo);function isSubsetOf(subset,superset,cmp){return subset.every(function(elem){if(!cmp)return-1!==superset.indexOf(elem);return superset.some(function(elem2){return cmp(elem,elem2)})})}Assertion.addMethod("members",function(subset,msg){if(msg)flag(this,"message",msg);var obj=flag(this,"object");new Assertion(obj).to.be.an("array");new Assertion(subset).to.be.an("array");var cmp=flag(this,"deep")?_.eql:void 0;if(flag(this,"contains")){return this.assert(isSubsetOf(subset,obj,cmp),"expected #{this} to be a superset of #{act}","expected #{this} to not be a superset of #{act}",obj,subset)}this.assert(isSubsetOf(obj,subset,cmp)&&isSubsetOf(subset,obj,cmp),"expected #{this} to have the same members as #{act}","expected #{this} to not have the same members as #{act}",obj,subset)});function oneOf(list,msg){if(msg)flag(this,"message",msg);var expected=flag(this,"object");new Assertion(list).to.be.an("array");this.assert(-1<list.indexOf(expected),"expected #{this} to be one of #{exp}","expected #{this} to not be one of #{exp}",list,expected)}Assertion.addMethod("oneOf",oneOf);function assertChanges(object,prop,msg){if(msg)flag(this,"message",msg);var fn=flag(this,"object");new Assertion(object,msg).to.have.property(prop);new Assertion(fn).is.a("function");var initial=object[prop];fn();this.assert(initial!==object[prop],"expected ."+prop+" to change","expected ."+prop+" to not change")}Assertion.addChainableMethod("change",assertChanges);Assertion.addChainableMethod("changes",assertChanges);function assertIncreases(object,prop,msg){if(msg)flag(this,"message",msg);var fn=flag(this,"object");new Assertion(object,msg).to.have.property(prop);new Assertion(fn).is.a("function");var initial=object[prop];fn();this.assert(0<object[prop]-initial,"expected ."+prop+" to increase","expected ."+prop+" to not increase")}Assertion.addChainableMethod("increase",assertIncreases);Assertion.addChainableMethod("increases",assertIncreases);function assertDecreases(object,prop,msg){if(msg)flag(this,"message",msg);var fn=flag(this,"object");new Assertion(object,msg).to.have.property(prop);new Assertion(fn).is.a("function");var initial=object[prop];fn();this.assert(0>object[prop]-initial,"expected ."+prop+" to decrease","expected ."+prop+" to not decrease")}Assertion.addChainableMethod("decrease",assertDecreases);Assertion.addChainableMethod("decreases",assertDecreases);Assertion.addProperty("extensible",function(){var obj=flag(this,"object"),isExtensible;try{isExtensible=Object.isExtensible(obj)}catch(err){if(err instanceof TypeError)isExtensible=!1;else throw err}this.assert(isExtensible,"expected #{this} to be extensible","expected #{this} to not be extensible")});Assertion.addProperty("sealed",function(){var obj=flag(this,"object"),isSealed;try{isSealed=Object.isSealed(obj)}catch(err){if(err instanceof TypeError)isSealed=!0;else throw err}this.assert(isSealed,"expected #{this} to be sealed","expected #{this} to not be sealed")});Assertion.addProperty("frozen",function(){var obj=flag(this,"object"),isFrozen;try{isFrozen=Object.isFrozen(obj)}catch(err){if(err instanceof TypeError)isFrozen=!0;else throw err}this.assert(isFrozen,"expected #{this} to be frozen","expected #{this} to not be frozen")})};