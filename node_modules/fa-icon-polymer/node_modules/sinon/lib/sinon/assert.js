(function(sinonGlobal,global){"use strict";var slice=Array.prototype.slice;function makeApi(sinon){var assert;function verifyIsStub(){for(var method,i=0,l=arguments.length;i<l;++i){method=arguments[i];if(!method){assert.fail("fake is not a spy")}if(method.proxy&&method.proxy.isSinonProxy){verifyIsStub(method.proxy)}else{if("function"!==typeof method){assert.fail(method+" is not a function")}if("function"!==typeof method.getCall){assert.fail(method+" is not stubbed")}}}}function verifyIsValidAssertion(assertionMethod,assertionArgs){switch(assertionMethod){case"notCalled":case"called":case"calledOnce":case"calledTwice":case"calledThrice":if(0!==assertionArgs.length){assert.fail(assertionMethod+" takes 1 argument but was called with "+(assertionArgs.length+1)+" arguments")}break;default:break;}}function failAssertion(object,msg){object=object||global;var failMethod=object.fail||assert.fail;failMethod.call(object,msg)}function mirrorPropAsAssertion(name,method,message){if(2===arguments.length){message=method;method=name}assert[name]=function(fake){verifyIsStub(fake);var args=slice.call(arguments,1);verifyIsValidAssertion(name,args);var failed=!1;if("function"===typeof method){failed=!method(fake)}else{failed="function"===typeof fake[method]?!fake[method].apply(fake,args):!fake[method]}if(failed){failAssertion(this,(fake.printf||fake.proxy.printf).apply(fake,[message].concat(args)))}else{assert.pass(name)}}}function exposedName(prefix,prop){return!prefix||/^fail/.test(prop)?prop:prefix+prop.slice(0,1).toUpperCase()+prop.slice(1)}assert={failException:"AssertError",fail:function fail(message){var error=new Error(message);error.name=this.failException||assert.failException;throw error},pass:function pass(){},callOrder:function assertCallOrder(){verifyIsStub.apply(null,arguments);var expected="",actual="";if(!sinon.calledInOrder(arguments)){try{expected=[].join.call(arguments,", ");var calls=slice.call(arguments),i=calls.length;while(i){if(!calls[--i].called){calls.splice(i,1)}}actual=sinon.orderByFirstCall(calls).join(", ")}catch(e){}failAssertion(this,"expected "+expected+" to be "+"called in order but were called as "+actual)}else{assert.pass("callOrder")}},callCount:function assertCallCount(method,count){verifyIsStub(method);if(method.callCount!==count){var msg="expected %n to be called "+sinon.timesInWords(count)+" but was called %c%C";failAssertion(this,method.printf(msg))}else{assert.pass("callCount")}},expose:function expose(target,options){if(!target){throw new TypeError("target is null or undefined")}var o=options||{},prefix="undefined"===typeof o.prefix&&"assert"||o.prefix,includeFail="undefined"===typeof o.includeFail||!!o.includeFail;for(var method in this){if("expose"!==method&&(includeFail||!/^(fail)/.test(method))){target[exposedName(prefix,method)]=this[method]}}return target},match:function match(actual,expectation){var matcher=sinon.match(expectation);if(matcher.test(actual)){assert.pass("match")}else{var formatted=["expected value to match","    expected = "+sinon.format(expectation),"    actual = "+sinon.format(actual)];failAssertion(this,formatted.join("\n"))}}};mirrorPropAsAssertion("called","expected %n to have been called at least once but was never called");mirrorPropAsAssertion("notCalled",function(spy){return!spy.called},"expected %n to not have been called but was called %c%C");mirrorPropAsAssertion("calledOnce","expected %n to be called once but was called %c%C");mirrorPropAsAssertion("calledTwice","expected %n to be called twice but was called %c%C");mirrorPropAsAssertion("calledThrice","expected %n to be called thrice but was called %c%C");mirrorPropAsAssertion("calledOn","expected %n to be called with %1 as this but was called with %t");mirrorPropAsAssertion("alwaysCalledOn","expected %n to always be called with %1 as this but was called with %t");mirrorPropAsAssertion("calledWithNew","expected %n to be called with new");mirrorPropAsAssertion("alwaysCalledWithNew","expected %n to always be called with new");mirrorPropAsAssertion("calledWith","expected %n to be called with arguments %*%C");mirrorPropAsAssertion("calledWithMatch","expected %n to be called with match %*%C");mirrorPropAsAssertion("alwaysCalledWith","expected %n to always be called with arguments %*%C");mirrorPropAsAssertion("alwaysCalledWithMatch","expected %n to always be called with match %*%C");mirrorPropAsAssertion("calledWithExactly","expected %n to be called with exact arguments %*%C");mirrorPropAsAssertion("alwaysCalledWithExactly","expected %n to always be called with exact arguments %*%C");mirrorPropAsAssertion("neverCalledWith","expected %n to never be called with arguments %*%C");mirrorPropAsAssertion("neverCalledWithMatch","expected %n to never be called with match %*%C");mirrorPropAsAssertion("threw","%n did not throw exception%C");mirrorPropAsAssertion("alwaysThrew","%n did not always throw exception%C");sinon.assert=assert;return assert}var isNode="undefined"!==typeof module&&module.exports&&"function"===typeof require,isAMD="function"===typeof define&&"object"===typeof define.amd&&define.amd;function loadDependencies(require,exports,module){var sinon=require("./util/core");require("./match");require("./format");module.exports=makeApi(sinon)}if(isAMD){define(loadDependencies);return}if(isNode){loadDependencies(require,module.exports,module);return}if(sinonGlobal){makeApi(sinonGlobal)}})("object"===typeof sinon&&sinon,"undefined"!==typeof global?global:self);