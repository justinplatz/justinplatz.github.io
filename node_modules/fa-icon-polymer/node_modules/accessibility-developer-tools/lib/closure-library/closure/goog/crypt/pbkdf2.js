goog.provide("goog.crypt.pbkdf2");goog.require("goog.array");goog.require("goog.asserts");goog.require("goog.crypt");goog.require("goog.crypt.Hmac");goog.require("goog.crypt.Sha1");goog.crypt.pbkdf2.deriveKeySha1=function(password,initialSalt,iterations,keyLength){var HASH_LENGTH=160,computeBlock=function(index){for(var result=goog.array.repeat(0,HASH_LENGTH/8),salt=initialSalt.concat(index),hmac=new goog.crypt.Hmac(new goog.crypt.Sha1(),password,64),i=0;i<iterations;i++){salt=hmac.getHmac(salt);result=goog.crypt.xorByteArray(result,salt)}return result};return goog.crypt.pbkdf2.deriveKeyFromPassword_(computeBlock,HASH_LENGTH,keyLength)};goog.crypt.pbkdf2.deriveKeyFromPassword_=function(computeBlock,hashLength,keyLength){goog.asserts.assert(0==keyLength%8,"invalid output key length");var numBlocks=Math.ceil(keyLength/hashLength);goog.asserts.assert(1<=numBlocks,"invalid number of blocks");for(var result=[],i=1,indexBytes;i<=numBlocks;i++){indexBytes=goog.crypt.pbkdf2.integerToByteArray_(i);result=result.concat(computeBlock(indexBytes))}var lastBlockSize=keyLength%hashLength;if(0!=lastBlockSize){var desiredBytes=((numBlocks-1)*hashLength+lastBlockSize)/8;result.splice(desiredBytes,(hashLength-lastBlockSize)/8)}return result};goog.crypt.pbkdf2.integerToByteArray_=function(n){var result=[,,,,];result[0]=255&n>>24;result[1]=255&n>>16;result[2]=255&n>>8;result[3]=255&n;return result};